<Header title='{{title}}' subtitle='{{subtitle}}' />
<div id="q-election-seat-svg-container" class="q-election-seat-svg-container"></div>
<div class="q-election-seat-total s-font-note">{{totalSeats}} Sitze</div>
<div class="q-election-seat-text-container">
  <div class="q-election-seat-legend">
    {{#each partyBunches as partyBunch}}
      <ElectionItems parties='{{partyBunch}}' />
    {{/each}}
  </div>
  <Footer notes='{{notes}}' sources='{{sources}}' maxResult='{{maxResult}}' updatedDate='{{updatedDate}}' />
</div>


<script>
  import Header from './Header.html';
  import Footer from './Footer.html';
  import ElectionItems from './ElectionItems.html';

  export default {
    computed: {
      sortedParties: (parties) => {
        if (parties !== undefined) {
          return parties.sort((partyA, partyB) => {
            if (partyA.seats === undefined) {
              partyA.seats = 0;
            }
            if (partyB.seats === undefined) {
              partyB.seats = 0;
            }
            return partyB.seats - partyA.seats;
          })
        } else {
          return [];
        }
      },
      partyBunches: (sortedParties, totalSeats) => {
        // add party object for vacant seats if total available seats 
        // is bigger than sum of all parties' seats
        let sumSeats = sortedParties
          .map(party => party.seats)
          .reduce((sum, partySeats) => {
            return sum + partySeats;
          }, 0);
        let vacantSeats = totalSeats - sumSeats;
        if (vacantSeats > 0) {
          sortedParties.push({
            name: 'vakant',
            color: {
              classAttribute: 's-color-gray-4'
            },
            seats: vacantSeats
          })
        }
        
        sortedParties.forEach(party => {
          // define color of each party's arc either via class attribute or color code
          let colorStyle = '';
          let colorClass = '';
          if (party.color) {
            if (party.color.classAttribute) {
              colorClass = party.color.classAttribute;
            } else {
              colorStyle = 'background-color: ' + party.color.colorCode + ';';
            }
          }
          party.colorClass = colorClass;
          party.colorStyle = colorStyle;

          // calculate trend and degree of trend arrow
          if (party.seats) {
            if (party.previous) {
              party.trend = party.seats - party.previous;
            } else {
              party.trend = party.seats;
            }

            // max amplitude of the trend arrow is 90Â° plus or minus
            // this correlates to gaining or loosing 5% of total available seats
            let maxAmp = (totalSeats * 5) / 100;
            let trendDegree = (Math.min(Math.abs(party.trend),maxAmp) * 90) / maxAmp;
            if (party.trend > 0 ) {
              trendDegree = -trendDegree;
            }
            party.trendDegree = trendDegree;
          }

          // parties which are summarized under "others" or vacancies will not have a trend
          let stringPattern = /((.*(A|a)ndere.*)|(.*(S|s)onstig.*)|(.*(V|v)akant.*))/;
          party.isRealParty = !stringPattern.test(party.name);
        })

        // split party array into two halfs and create another array out of it
        // in order to make a two columned legend if width is sufficient
        let half = Math.ceil(sortedParties.length / 2);
        let partiesFirstHalf = sortedParties.slice(0, half);
        let partiesSecondHalf = sortedParties.slice(half);
        sortedParties = [partiesFirstHalf, partiesSecondHalf];
        return sortedParties;
      },
      maxResult: (sortedParties) => {
        return sortedParties[0].seats;
      }
    },
    components: {
      Header,
      ElectionItems,
      Footer
    }
  };
</script>
