<div class="q-election-seats" style="opacity: 0;">
  <Header title='{{item.title}}' hideTitle='{{hideTitle}}' subtitle='{{item.subtitle}}' />
  <div id="q-election-seats-svg-container" class="q-election-seats-svg-container"></div>
  <div class="q-election-seats-total s-font-note">{{totalSeats}} Sitze</div>
  <div class="q-election-seats-text-container">
    <div class="q-election-seats-legend">
      {{#each electedPartyBunches as electedPartyBunch}}
        <ElectionItems parties='{{electedPartyBunch}}' />
      {{/each}}
      {{#if notElectedPartyBunches.length > 0}}
        <div class="q-election-seats-separator s-color-gray-4"></div>
        {{#each notElectedPartyBunches as notElectedPartyBunch}}
          <ElectionItems parties='{{notElectedPartyBunch}}' />
        {{/each}}
      {{/if}}
    </div>
    <Footer notes='{{item.notes}}' sources='{{item.sources}}' hasResult='{{hasResult}}' updatedDate='{{item.updatedDate}}' />
  </div>
</div>


<script>
  import Header from './Header.html';
  import Footer from './Footer.html';
  import ElectionItems from './ElectionItems.html';

  export default {
    computed: {
      hideTitle: (toolRuntimeConfig) => {
        return toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle;
      },
      parties: (item) => {
        return item.parties;
      },
      sumSeats: (parties) => {
        return parties
          .map(party => party.seats || 0)
          .reduce((sum, partySeats) => {
            return sum + partySeats;
          }, 0);
      },
      totalSeats: (item) => {
        return item.totalSeats;
      },
      enhancedParties: (parties, totalSeats, sumSeats) => {
        // add party object for vacant seats if total available seats 
        // is bigger than sum of all parties' seats
        let vacantSeats = totalSeats - sumSeats;
        if (vacantSeats > 0) {
          parties.push({
            name: 'vakant',
            color: {
              classAttribute: 's-color-gray-4'
            },
            seats: vacantSeats
          })
        }
        
        parties.forEach(party => {
          // define color of each party's arc either via class attribute or color code
          let colorStyle = '';
          let colorClass = '';
          if (party.color) {
            if (party.color.classAttribute) {
              colorClass = party.color.classAttribute;
            } else {
              colorStyle = 'background-color: ' + party.color.colorCode + ';';
            }
          }
          party.colorClass = colorClass;
          party.colorStyle = colorStyle;

          // calculate trend and degree of trend arrow
          if (party.seats !== undefined) {
            party.hasSeats = true;
            if (party.previous !== undefined) {
              party.hasPrevious = true;
              party.trend = party.seats - party.previous;
            } else {
              party.hasPrevious = false;
              party.trend = party.seats;
            }

            // max amplitude of the trend arrow is 90Â° plus or minus
            // this correlates to gaining or loosing 5% of total available seats
            let maxAmp = (totalSeats * 5) / 100;
            let trendDegree = (Math.min(Math.abs(party.trend),maxAmp) * 90) / maxAmp;
            if (party.trend > 0 ) {
              trendDegree = -trendDegree;
            }
            party.trendDegree = trendDegree;
          } else {
            party.hasSeats = false;
          }

          // parties which are summarized under "others" or vacancies will not have a trend
          let vacantPattern = /(.*(V|v)akant.*)/;
          party.isVacant = vacantPattern.test(party.name);
        })
        return parties;
      },
      notElectedParties: (enhancedParties) => {
        // filter all parties with no seats
        return enhancedParties.filter(party => {
          return party.seats !== undefined && party.seats === 0;
        });
      },
      notElectedPartyBunches: (notElectedParties) => {
        // split party array into two halfs and create another array out of it
        // in order to make a two columned legend if width is sufficient
        if (notElectedParties !== undefined && notElectedParties.length > 0) {
          let half = Math.ceil(notElectedParties.length / 2);
          let partiesFirstHalf = notElectedParties.slice(0, half);
          let partiesSecondHalf = notElectedParties.slice(half);
          notElectedParties = [partiesFirstHalf, partiesSecondHalf];
        }
        return notElectedParties;
      },
      electedPartyBunches: (enhancedParties, notElectedParties) => {
        // filter all parties which have one or more seats
        let elected = enhancedParties;
        if (notElectedParties !== undefined && notElectedParties.length > 0) {
          elected = enhancedParties.filter(party => {
            return notElectedParties.indexOf(party) < 0;
          });
        }

        let half = Math.ceil(elected.length / 2);
        let partiesFirstHalf = elected.slice(0, half);
        let partiesSecondHalf = elected.slice(half);
        elected = [partiesFirstHalf, partiesSecondHalf];
        return elected;
      },
      hasResult: (sumSeats) => {
        return sumSeats > 0;
      }
    },
    components: {
      Header,
      ElectionItems,
      Footer
    }
  };
</script>
